# include <bits/stdc++.h>
# include "../TimeMacro.h"
using namespace std;
typedef long long int ll;

/*
Statement:
 Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the 
 following formulae:
 
 Triangle	 	P(3,n)=n(n+1)/2	 	1, 3, 6, 10, 15, ...
 Square	 	    P(4,n)=n^2	 	1, 4, 9, 16, 25, ...
 Pentagonal	 	P(5,n)=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
 Hexagonal	 	P(6,n)=n(2n−1)	 	1, 6, 15, 28, 45, ...
 Heptagonal	 	P(7,n)=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
 Octagonal	 	P(8,n)=n(3n−2)	 	1, 8, 21, 40, 65, ...
 The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
 
 1. The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number 
 with the first).
 2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different 
 number in the set.
 3. This is the only set of 4-digit numbers with this property.
 
 Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, 
 heptagonal, and octagonal, is represented by a different number in the set.
*/

ll polygonalNum(ll n, ll sides){
    return (sides - 2) * n * (n-1) / 2 + n;
}

 ll getCyclicFiguratesSum(int digitLen, vector<int> sides){
    int boundHalf = 1;
    for(int i = 0; i<digitLen/2; i++) boundHalf *= 10;
    int fullBound = 1;
    for(int i = 0; i<digitLen; i++) fullBound *= 10;


    vector<vector<map<int, vector<int>>>> memoTable(sides.size()); 
    for(int i = 0; i<sides.size(); i++){
        memoTable[i].resize(boundHalf);
        int side = sides[i];
        for(int index = 0; ;index++){
            int num = polygonalNum(index, side);
            if(num < fullBound/10) continue;
            if(num >= fullBound) break;

            int part1 = num/boundHalf, part2 = num%boundHalf;

            if(i == 0){
                memoTable[i][part1][part2].push_back(num);
            }
            else{
                for(auto &p : memoTable[i-1][part2]){
                    memoTable[i][part1][p.first].push_back(num);
                }
            }

        }
    }

    for(int part = boundHalf/10; part < boundHalf; part++){
        if(memoTable[sides.size()-1][part].count(part)){
            ll sum = 0;
            int first = part;
            for(int i = sides.size()-1; i>=0; i--){
                int num = memoTable[i][first][part][0];
                sum += num;
                first = num%boundHalf;
            }
            return sum;
        }
    }
    return 0;
}

ll sumCyclicFiguratesOfLenghth(int digitLen, int size){
    vector<int> sides(size);
    iota(sides.begin(), sides.end(), 3);
    ll sum = 0;
    do{
        sum = getCyclicFiguratesSum(digitLen, sides);
        if(sum != 0) break;
    }while(next_permutation(sides.begin(), sides.end()));
    return sum;
}

int main(){
    Time(
        cout<<sumCyclicFiguratesOfLenghth(4, 6)<<endl;
    )
    return 0;
}

/*
Notes:
 For all possible permutation of the sides, we try to find chain of numbers for each prefix of the sides. Note that only last part and
 first part are needed, so memo[i][part1][part2] keeps vector of numbers who end the chain at length i, with last being part1 and start 
 being part2. so in the end we can trace back from memo[size][part][part].
 Complexity:O(10^(3n/2) * m!)
*/