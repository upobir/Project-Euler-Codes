# include <bits/stdc++.h>
# include "../TimeMacro.h"
using namespace std;
typedef long long int ll;

/*
Statement:
 Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:

 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

 It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.

 Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk − Pj| is minimised; 
 what is the value of D?
*/

class divisorsDynamicSieve{
private:
    vector<vector<int>> divisors;

    void resieveUntil(int maxNum){
        int prvMax = divisors.size();
        divisors.resize(maxNum);
        for(int d = 1; d < maxNum; d++){
            for(int m = d * ((prvMax-1)/d+1); m<maxNum; m += d)
                divisors[m].push_back(d);
        }
        return;
    }

public:
    divisorsDynamicSieve(){
        divisors.resize(1);
    }

    int lastComputed(){
        return divisors.size()-1;
    }

    vector<int>& operator[](int number){
        while(number >= divisors.size())
            resieveUntil(2*divisors.size());
        return divisors[number];
    }
};

# define det(a, b, c, d) ((a)*(d) - (b)*(c))
bool integer2dEqnSolution(pair<ll, ll> xC, pair<ll, ll> yC, pair<ll, ll> val, ll &x, ll &y){
    ll del = det(xC.first, yC.first, xC.second, yC.second);
    ll xDel = det(val.first, yC.first, val.second, yC.second);
    ll yDel = det(xC.first, val.first, xC.second, val.second);
    if(xDel % del != 0 || yDel % del != 0) return false;
    x = xDel/del;
    y = yDel/del;
    return true;
}

ll polygonalNum(ll n, ll sides){
    return (sides - 2) * n * (n-1) / 2 + n;
}

ll invPolygonalNum(ll polygonalNum, ll sides){
    double C = sides - 2;
    double desc = C*C/2.0 - C + 1.0 + 2.0*C*polygonalNum;
    if(desc < 0) return -1;
    ll num = llround((C/2.0-1.0+sqrtl(desc))/C);
    if ((sides-2)*num*(num-1)/2 + num == polygonalNum)
        return num;
    return -1;
}

ll minimumPentagonalDifferenceAndSum(){
    divisorsDynamicSieve sDivisors;

    for(int d = 1; ; d++){
        ll part1 = d;
        ll part2 = 3*d-1;

        for(int d1 : sDivisors[part1])
            for(int d2 : sDivisors[part2]){
                ll divi1 = 1ll*d1*d2;
                ll divi2 = 1ll*(part1/d1) * (part2/d2);
                ll i, j;

                if(!integer2dEqnSolution({1, 3}, {-1, 3}, {divi1, divi2+1}, i, j)) continue;
                if(i <= 0 || j <= 0) continue;

                ll Pi = polygonalNum(i, 5);
                ll Pj = polygonalNum(j, 5);

                if(invPolygonalNum(Pi+Pj, 5) != -1){
                    return part1*part2/2;
                }
            }
    }
}

int main(){
    Time(
        cout<<minimumPentagonalDifferenceAndSum()<<endl;   
    )
    return 0;
}

/*
Statement:
 Since we want samllest difference, so we iterated on that, for each d from 1, we tried to find i, j such that Pi-Pj = Pd and Pi+Pj was also
 a pentagonal number. To do this note that Pi-Pj=Pd -> (i-j)(3i+3j-1) = d(3d-1). So by iterating on divisors of d(3d-1) and checkin to solve
 divi1 = i-j & divi2 = 3i+3j-1 we could get the answers by using invPolygonalNum() function from before. Now we do not know how long we have
 to wait, so we should've used sqrt divisor finding, but that'd be slow, so we used two tricks, first d and 3d-1 are coprime, so using their
 divisors we can find combined divisor of d(3d-1) and we made a dynamic sieve system, that is when a number's divisors are needed which is 
 out of range, we use table doubling method to get to it. This way we get an amortized efficient algorithm.
 Complexity: O(X * log^2 X)
*/