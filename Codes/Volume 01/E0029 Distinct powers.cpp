# include <bits/stdc++.h>
# include "../TimeMacro.h"
using namespace std;
typedef long long int ll;

/*
Statement:
 Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

 2^2=4, 2^3=8, 2^4=16, 2^5=32
 3^2=9, 3^3=27, 3^4=81, 3^5=243
 4^2=16, 4^3=64, 4^4=256, 4^5=1024
 5^2=25, 5^3=125, 5^4=625, 5^5=3125
 If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

 How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
*/

vector<pair<int, int>> powerSieveTill(int maxNum){
    vector<pair<int,int>> base(maxNum+1);
    base[1] = {1, 0};
    for(int num = 2; num <= maxNum; num++){
        if(base[num].first != 0) continue;
        ll poweredNum = num, exponent = 1;
        while(poweredNum <= maxNum){
            base[poweredNum] = {num, exponent};
            poweredNum *= num;
            exponent++;
        }
    }
    return base;
}

// 1 < base and 1 < power considered
ll countDistinctPowers(int boundBase, int boundPower){
    vector<pair<int,int>> base = powerSieveTill(boundBase);

    unordered_set<int> powerProducts;
    int maxPower = 0;
    ll ans = 0;
    for(int num = boundBase; num > 1; num--){
        if(base[num].second > 1) continue;

        ll poweredNum = num, exponent = 0;
        while(poweredNum <= boundBase){
            exponent++;
            poweredNum *= num;
        }

        while(exponent > maxPower){
            maxPower++;
            for(int stdPower = 2; stdPower <= boundPower; stdPower++){
                int product = maxPower*stdPower;
                powerProducts.insert(product);
            }
        }

        ans += powerProducts.size();
    }
    return ans;
}

int main(){
    Time(
        cout<<countDistinctPowers(100, 100)<<endl;
    )
    return 0;
}

/*
Notes:
 Any number a^b can be put in a canonical form of x^(by) where x is thes smallest number s.t. a = x^y. For same numbers this canonical form
 is unique, so we count the numbers from each x. First we use a sieve to find those numbers for whom y = 1, that is they are the x 
 themselves. Then for each x, we count how many x^(by) is possible, note that x^y <= baseBound and b <= powerBound, we just try all such
 b and y and keep their products in a set to keep count of x^(by). The code is done in reverse looping for optimization as smaller numbers have larger y possible.
 Complexity: O(n + m * log n)
*/